{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../node_modules/svelte/motion/index.mjs","../../node_modules/svelte-range-slider-pips/src/RangePips.svelte","../../node_modules/svelte-range-slider-pips/src/RangeSlider.svelte","../../node_modules/@turf/helpers/dist/es/index.js","../../node_modules/@turf/invariant/dist/es/index.js","../../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../../node_modules/@turf/meta/dist/es/index.js","../../node_modules/@turf/line-segment/dist/es/index.js","../../node_modules/quickselect/quickselect.js","../../node_modules/rbush/index.js","../../node_modules/@turf/helpers/dist/js/index.js","../../node_modules/@turf/meta/dist/js/index.js","../../node_modules/@turf/bbox/dist/js/index.js","../../node_modules/geojson-rbush/index.js","../../node_modules/@turf/line-intersect/dist/es/index.js","../../node_modules/@turf/polygon-to-line/dist/es/index.js","../../node_modules/@turf/boolean-disjoint/dist/es/index.js","../../src/App.svelte","../../node_modules/@turf/boolean-intersects/dist/es/index.js","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.2' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from '../store/index.mjs';\nimport { now, loop, assign } from '../internal/index.mjs';\nimport { linear } from '../easing/index.mjs';\n\nfunction is_date(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n}\n\nfunction tick_spring(ctx, last_value, current_value, target_value) {\n    if (typeof current_value === 'number' || is_date(current_value)) {\n        // @ts-ignore\n        const delta = target_value - current_value;\n        // @ts-ignore\n        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\n        const spring = ctx.opts.stiffness * delta;\n        const damper = ctx.opts.damping * velocity;\n        const acceleration = (spring - damper) * ctx.inv_mass;\n        const d = (velocity + acceleration) * ctx.dt;\n        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\n            return target_value; // settled\n        }\n        else {\n            ctx.settled = false; // signal loop to keep ticking\n            // @ts-ignore\n            return is_date(current_value) ?\n                new Date(current_value.getTime() + d) : current_value + d;\n        }\n    }\n    else if (Array.isArray(current_value)) {\n        // @ts-ignore\n        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\n    }\n    else if (typeof current_value === 'object') {\n        const next_value = {};\n        for (const k in current_value) {\n            // @ts-ignore\n            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\n        }\n        // @ts-ignore\n        return next_value;\n    }\n    else {\n        throw new Error(`Cannot spring ${typeof current_value} values`);\n    }\n}\nfunction spring(value, opts = {}) {\n    const store = writable(value);\n    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;\n    let last_time;\n    let task;\n    let current_token;\n    let last_value = value;\n    let target_value = value;\n    let inv_mass = 1;\n    let inv_mass_recovery_rate = 0;\n    let cancel_task = false;\n    function set(new_value, opts = {}) {\n        target_value = new_value;\n        const token = current_token = {};\n        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {\n            cancel_task = true; // cancel any running animation\n            last_time = now();\n            last_value = new_value;\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        else if (opts.soft) {\n            const rate = opts.soft === true ? .5 : +opts.soft;\n            inv_mass_recovery_rate = 1 / (rate * 60);\n            inv_mass = 0; // infinite mass, unaffected by spring forces\n        }\n        if (!task) {\n            last_time = now();\n            cancel_task = false;\n            task = loop(now => {\n                if (cancel_task) {\n                    cancel_task = false;\n                    task = null;\n                    return false;\n                }\n                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\n                const ctx = {\n                    inv_mass,\n                    opts: spring,\n                    settled: true,\n                    dt: (now - last_time) * 60 / 1000\n                };\n                const next_value = tick_spring(ctx, last_value, value, target_value);\n                last_time = now;\n                last_value = value;\n                store.set(value = next_value);\n                if (ctx.settled) {\n                    task = null;\n                }\n                return !ctx.settled;\n            });\n        }\n        return new Promise(fulfil => {\n            task.promise.then(() => {\n                if (token === current_token)\n                    fulfil();\n            });\n        });\n    }\n    const spring = {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe,\n        stiffness,\n        damping,\n        precision\n    };\n    return spring;\n}\n\nfunction get_interpolator(a, b) {\n    if (a === b || a !== a)\n        return () => a;\n    const type = typeof a;\n    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n        throw new Error('Cannot interpolate values of different type');\n    }\n    if (Array.isArray(a)) {\n        const arr = b.map((bi, i) => {\n            return get_interpolator(a[i], bi);\n        });\n        return t => arr.map(fn => fn(t));\n    }\n    if (type === 'object') {\n        if (!a || !b)\n            throw new Error('Object cannot be null');\n        if (is_date(a) && is_date(b)) {\n            a = a.getTime();\n            b = b.getTime();\n            const delta = b - a;\n            return t => new Date(a + t * delta);\n        }\n        const keys = Object.keys(b);\n        const interpolators = {};\n        keys.forEach(key => {\n            interpolators[key] = get_interpolator(a[key], b[key]);\n        });\n        return t => {\n            const result = {};\n            keys.forEach(key => {\n                result[key] = interpolators[key](t);\n            });\n            return result;\n        };\n    }\n    if (type === 'number') {\n        const delta = b - a;\n        return t => a + t * delta;\n    }\n    throw new Error(`Cannot interpolate ${type} values`);\n}\nfunction tweened(value, defaults = {}) {\n    const store = writable(value);\n    let task;\n    let target_value = value;\n    function set(new_value, opts) {\n        if (value == null) {\n            store.set(value = new_value);\n            return Promise.resolve();\n        }\n        target_value = new_value;\n        let previous_task = task;\n        let started = false;\n        let { delay = 0, duration = 400, easing = linear, interpolate = get_interpolator } = assign(assign({}, defaults), opts);\n        if (duration === 0) {\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            store.set(value = target_value);\n            return Promise.resolve();\n        }\n        const start = now() + delay;\n        let fn;\n        task = loop(now => {\n            if (now < start)\n                return true;\n            if (!started) {\n                fn = interpolate(value, new_value);\n                if (typeof duration === 'function')\n                    duration = duration(value, new_value);\n                started = true;\n            }\n            if (previous_task) {\n                previous_task.abort();\n                previous_task = null;\n            }\n            const elapsed = now - start;\n            if (elapsed > duration) {\n                store.set(value = new_value);\n                return false;\n            }\n            // @ts-ignore\n            store.set(value = fn(easing(elapsed / duration)));\n            return true;\n        });\n        return task.promise;\n    }\n    return {\n        set,\n        update: (fn, opts) => set(fn(target_value, value), opts),\n        subscribe: store.subscribe\n    };\n}\n\nexport { spring, tweened };\n","<script>\n\n  // range slider props\n  export let range = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n\n  // range pips / values props\n  export let pipstep = undefined;\n  export let all = true;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = v => v;\n\n  // stylistic props\n  export let focus = undefined;\n  export let percentOf = undefined;\n\n  $: pipStep = pipstep || ((max - min) / step >= ( vertical ? 50 : 100 ) ? (max - min) / ( vertical ? 10 : 20 ) : 1);\n\n  $: pipCount = parseInt((max - min) / (step * pipStep), 10);\n\n  $: pipVal = function(val) {\n    return min + val * step * pipStep;\n  };\n\n  $: isSelected = function(val) {\n    return values.some(v => v === val);\n  };\n\n  $: inRange = function(val) {\n    if (range === \"min\") {\n      return values[0] > val;\n    } else if (range === \"max\") {\n      return values[0] < val;\n    } else if (range) {\n      return values[0] < val && values[1] > val;\n    }\n  };\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --pip: var(--range-pip, lightslategray);\n    --pip-text: var(--range-pip-text, var(--pip));\n    --pip-active: var(--range-pip-active, darkslategrey);\n    --pip-active-text: var(--range-pip-active-text, var(--pip-active));\n    --pip-in-range: var(--range-pip-in-range, var(--pip-active));\n    --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));\n  }\n  :global(.rangePips) {\n    position: absolute;\n    height: 1em;\n    left: 0;\n    right: 0;\n    bottom: -1em;\n  }\n  :global(.rangePips.vertical) {\n    height: auto;\n    width: 1em;\n    left: 100%;\n    right: auto;\n    top: 0;\n    bottom: 0;\n  }\n  :global(.rangePips .pip) {\n    height: 0.4em;\n    position: absolute;\n    top: 0.25em;\n    width: 1px;\n    white-space: nowrap;\n  }\n  :global(.rangePips.vertical .pip) {\n    height: 1px;\n    width: 0.4em;\n    top: 0;\n    left: 0.25em;\n  }\n  :global(.rangePips .pip.selected) {\n    height: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected) {\n    height: 1px;\n    width: 0.75em;\n  }\n  :global(.rangePips .pipVal) {\n    position: absolute;\n    top: 0.4em;\n    transform: translate(-50%, 25%);\n  }\n  :global(.rangePips.vertical .pipVal) {\n    position: absolute;\n    top: 0;\n    left: 0.4em;\n    transform: translate(25%, -50%);\n  }\n  :global(.rangePips .pip.selected .pipVal) {\n    font-weight: bold;\n    top: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected .pipVal) {\n    top: 0;\n    left: 0.75em;\n  }\n  :global(.rangePips .pip, .rangePips .pipVal) {\n    transition: all 0.15s ease;\n  }\n  :global(.rangePips .pip) {\n    color: lightslategray;\n    color: var(--pip-text);\n    background-color: lightslategray;\n    background-color: var(--pip);\n  }\n  :global(.rangePips .pip.selected) {\n    color: darkslategrey;\n    color: var(--pip-active-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-active);\n  }\n  :global(.rangePips .pip.in-range) {\n    color: darkslategrey;\n    color: var(--pip-in-range-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-in-range);\n  }\n</style>\n\n<div class=\"rangePips\" class:focus class:vertical>\n  {#if ( all && first !== false ) || first }\n    <span\n      class=\"pip first\"\n      class:selected={isSelected(min)}\n      class:in-range={inRange(min)}\n      style=\"{vertical ? 'top' : 'left'}: 0%;\">\n      {#if all === 'label' || first === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(min)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n  {#if ( all && rest !== false ) || rest}\n    {#each Array(pipCount + 1) as _, i}\n      {#if pipVal(i) !== min && pipVal(i) !== max}\n        <span\n          class=\"pip\"\n          class:selected={isSelected(pipVal(i))}\n          class:in-range={inRange(pipVal(i))}\n          style=\"{vertical ? 'top' : 'left'}: {percentOf(pipVal(i))}%;\">\n          {#if all === 'label' || rest === 'label'}\n            <span class=\"pipVal\">\n              {prefix}{formatter(pipVal(i))}{suffix}\n            </span>\n          {/if}\n        </span>\n      {/if}\n    {/each}\n  {/if}\n  {#if ( all && last !== false ) || last}\n    <span\n      class=\"pip last\"\n      class:selected={isSelected(max)}\n      class:in-range={inRange(max)}\n      style=\"{vertical ? 'top' : 'left'}: 100%;\">\n      {#if all === 'label' || last === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(max)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n</div>\n","<script>\n  import { spring } from \"svelte/motion\";\n  import { createEventDispatcher } from \"svelte\";\n  import RangePips from \"./RangePips.svelte\";\n\n  // range slider props\n  export let range = false;\n  export let pushy = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n  export let float = false;\n  export let hover = true;\n\n  // range pips / values props\n  export let pips = false;\n  export let pipstep = undefined;\n  export let all = undefined;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let id = undefined;\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = (v) => v;\n  export let handleFormatter = formatter;\n\n  // stylistic props\n  export let precision = 2;\n  export let springValues = { stiffness: 0.15, damping: 0.4 };\n\n  // prepare dispatched events\n  const dispatch = createEventDispatcher();\n\n  // dom references\n  let slider;\n\n  // state management\n  let focus = false;\n  let handleActivated = false;\n  let handlePressed = false;\n  let keyboardActive = false;\n  let activeHandle = values.length - 1;\n  let startValue;\n  let previousValue;\n\n  // copy the initial values in to a spring function which\n  // will update every time the values array is modified\n  let springPositions = spring(\n    values.map((v) =>\n      parseFloat((((v - min) / (max - min)) * 100).toFixed(precision))\n    ),\n    springValues\n  );\n\n  // check the values array, and trim it if needed (range)\n  // and clamp the values to the steps and boundaries set up in the slider\n  $: values = trimRange(values).map((v) => alignValueToStep(v));\n\n  // update the spring function so that movement can happen in the UI\n  $: {\n    springPositions.set(values.map((v) => percentOf(v)));\n  }\n\n  /**\n   * take in a value, and then calculate that value's percentage\n   * of the overall range (min-max);\n   * @param {number} val the value we're getting percent for\n   * @return {number} the percentage value\n   **/\n  $: percentOf = function (val) {\n    let perc = ((val - min) / (max - min)) * 100;\n    if (isNaN(perc) || perc <= 0) {\n      return 0;\n    } else if (perc >= 100) {\n      return 100;\n    } else {\n      return parseFloat(perc.toFixed(precision));\n    }\n  };\n\n  /**\n   * clamp a value from the range so that it always\n   * falls within the min/max values\n   * @param {number} val the value to clamp\n   * @return {number} the value after it's been clamped\n   **/\n  $: clampValue = function (val) {\n    // return the min/max if outside of that range\n    return val <= min ? min : val >= max ? max : val;\n  };\n\n  /**\n   * align the value with the steps so that it\n   * always sits on the closest (above/below) step\n   * @param {number} val the value to align\n   * @return {number} the value after it's been aligned\n   **/\n  $: alignValueToStep = function (val) {\n    // sanity check for performance\n    if (val <= min) {\n      return min;\n    } else if (val >= max) {\n      return max;\n    }\n\n    // find the middle-point between steps\n    // and see if the value is closer to the\n    // next step, or previous step\n    let remainder = (val - min) % step;\n    let aligned = val - remainder;\n    if (Math.abs(remainder) * 2 >= step) {\n      aligned += remainder > 0 ? step : -step;\n    }\n    // make sure the value is within acceptable limits\n    aligned = clampValue(aligned);\n    // make sure the returned value is set to the precision desired\n    // this is also because javascript often returns weird floats\n    // when dealing with odd numbers and percentages\n\n    return parseFloat(aligned.toFixed(precision));\n  };\n\n  /**\n   * helper func to get the index of an element in it's DOM container\n   * @param {object} el dom object reference we want the index of\n   * @returns {number} the index of the input element\n   **/\n  function index(el) {\n    if (!el) return -1;\n    var i = 0;\n    while ((el = el.previousElementSibling)) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * noramlise a mouse or touch event to return the\n   * client (x/y) object for that event\n   * @param {event} e a mouse/touch event to normalise\n   * @returns {object} normalised event client object (x,y)\n   **/\n  function normalisedClient(e) {\n    if (e.type.includes(\"touch\")) {\n      return e.touches[0];\n    } else {\n      return e;\n    }\n  }\n\n  /**\n   * check if an element is a handle on the slider\n   * @param {object} el dom object reference we want to check\n   * @returns {boolean}\n   **/\n  function targetIsHandle(el) {\n    const handles = slider.querySelectorAll(\".handle\");\n    const isHandle = Array.prototype.includes.call(handles, el);\n    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));\n    return isHandle || isChild;\n  }\n\n  /**\n   * trim the values array based on whether the property\n   * for 'range' is 'min', 'max', or truthy.\n   * @param {array} values the input values for the rangeSlider\n   * @return {array} the range array for creating a rangeSlider\n   **/\n  function trimRange(values) {\n    if (range === \"min\" || range === \"max\") {\n      return values.slice(0, 1);\n    } else if (range) {\n      return values.slice(0, 2);\n    } else {\n      return values;\n    }\n  }\n\n  /**\n   * helper to return the slider dimensions for finding\n   * the closest handle to user interaction\n   * @return {object} the range slider DOM client rect\n   **/\n  function getSliderDimensions() {\n    return slider.getBoundingClientRect();\n  }\n\n  /**\n   * helper to return closest handle to user interaction\n   * @param {object} clientPos the client{x,y} positions to check against\n   * @return {number} the index of the closest handle to clientPos\n   **/\n  function getClosestHandle(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let hPos = 0;\n    let hPercent = 0;\n    let hVal = 0;\n    if (vertical) {\n      hPos = clientPos.clientY - dims.top;\n      hPercent = (hPos / dims.height) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    } else {\n      hPos = clientPos.clientX - dims.left;\n      hPercent = (hPos / dims.width) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    }\n\n    let closest;\n\n    // if we have a range, and the handles are at the same\n    // position, we want a simple check if the interaction\n    // value is greater than return the second handle\n    if (range === true && values[0] === values[1]) {\n      if (hVal > values[1]) {\n        return 1;\n      } else {\n        return 0;\n      }\n      // if there are multiple handles, and not a range, then\n      // we sort the handles values, and return the first one closest\n      // to the interaction value\n    } else {\n      closest = values.indexOf(\n        [...values].sort((a, b) => Math.abs(hVal - a) - Math.abs(hVal - b))[0]\n      );\n    }\n    return closest;\n  }\n\n  /**\n   * take the interaction position on the slider, convert\n   * it to a value on the range, and then send that value\n   * through to the moveHandle() method to set the active\n   * handle's position\n   * @param {object} clientPos the client{x,y} of the interaction\n   **/\n  function handleInteract(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let hPos = 0;\n    let hPercent = 0;\n    let hVal = 0;\n    if (vertical) {\n      hPos = clientPos.clientY - dims.top;\n      hPercent = (hPos / dims.height) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    } else {\n      hPos = clientPos.clientX - dims.left;\n      hPercent = (hPos / dims.width) * 100;\n      hVal = ((max - min) / 100) * hPercent + min;\n    }\n    // move handle to the value\n    moveHandle(activeHandle, hVal);\n  }\n\n  /**\n   * move a handle to a specific value, respecting the clamp/align rules\n   * @param {number} index the index of the handle we want to move\n   * @param {number} value the value to move the handle to\n   * @return {number} the value that was moved to (after alignment/clamping)\n   **/\n  function moveHandle(index, value) {\n    // align & clamp the value so we're not doing extra\n    // calculation on an out-of-range value down below\n    value = alignValueToStep(value);\n    // if this is a range slider\n    if (range) {\n      // restrict the handles of a range-slider from\n      // going past one-another unless \"pushy\" is true\n      if (index === 0 && value > values[1]) {\n        if (pushy) {\n          values[1] = value;\n        } else {\n          value = values[1];\n        }\n      } else if (index === 1 && value < values[0]) {\n        if (pushy) {\n          values[0] = value;\n        } else {\n          value = values[0];\n        }\n      }\n    }\n\n    // if the value has changed, update it\n    if (values[index] !== value) {\n      values[index] = value;\n    }\n\n    // fire the change event when the handle moves,\n    // and store the previous value for the next time\n    if (previousValue !== value) {\n      eChange();\n      previousValue = value;\n    }\n  }\n\n  /**\n   * helper to find the beginning range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the beginning of the range\n   **/\n  function rangeStart(values) {\n    if (range === \"min\") {\n      return 0;\n    } else {\n      return values[0];\n    }\n  }\n\n  /**\n   * helper to find the ending range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the end of the range\n   **/\n  function rangeEnd(values) {\n    if (range === \"max\") {\n      return 0;\n    } else if (range === \"min\") {\n      return 100 - values[0];\n    } else {\n      return 100 - values[1];\n    }\n  }\n\n  /**\n   * when the user has unfocussed (blurred) from the\n   * slider, deactivated all handles\n   * @param {event} e the event from browser\n   **/\n  function sliderBlurHandle(e) {\n    if (keyboardActive) {\n      focus = false;\n      handleActivated = false;\n      handlePressed = false;\n    }\n  }\n\n  /**\n   * when the user focusses the handle of a slider\n   * set it to be active\n   * @param {event} e the event from browser\n   **/\n  function sliderFocusHandle(e) {\n    activeHandle = index(e.target);\n    focus = true;\n  }\n\n  /**\n   * handle the keyboard accessible features by checking the\n   * input type, and modfier key then moving handle by appropriate amount\n   * @param {event} e the event from browser\n   **/\n  function sliderKeydown(e) {\n    const handle = index(e.target);\n    let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;\n    let prevent = false;\n\n    switch (e.key) {\n      case \"PageDown\":\n        jump *= 10;\n      case \"ArrowRight\":\n      case \"ArrowUp\":\n        moveHandle(handle, values[handle] + jump);\n        prevent = true;\n        break;\n      case \"PageUp\":\n        jump *= 10;\n      case \"ArrowLeft\":\n      case \"ArrowDown\":\n        moveHandle(handle, values[handle] - jump);\n        prevent = true;\n        break;\n      case \"Home\":\n        moveHandle(handle, min);\n        prevent = true;\n        break;\n      case \"End\":\n        moveHandle(handle, max);\n        prevent = true;\n        break;\n    }\n    if (prevent) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  /**\n   * function to run when the user touches\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractStart(e) {\n    const clientPos = normalisedClient(e);\n    // set the closest handle as active\n    focus = true;\n    handleActivated = true;\n    handlePressed = true;\n    activeHandle = getClosestHandle(clientPos);\n\n    // fire the start event\n    startValue = previousValue = alignValueToStep(values[activeHandle]);\n    eStart();\n\n    // for touch devices we want the handle to instantly\n    // move to the position touched for more responsive feeling\n    if (e.type === \"touchstart\") {\n      handleInteract(clientPos);\n    }\n  }\n\n  /**\n   * function to run when the user stops touching\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractEnd(e) {\n    // fire the stop event for touch devices\n    if (e.type === \"touchend\") {\n      eStop();\n    }\n    handlePressed = false;\n  }\n\n  /**\n   * unfocus the slider if the user clicked off of\n   * it, somewhere else on the screen\n   * @param {event} e the event from browser\n   **/\n  function bodyInteractStart(e) {\n    keyboardActive = false;\n    if (focus && e.target !== slider && !slider.contains(e.target)) {\n      focus = false;\n    }\n  }\n\n  /**\n   * send the clientX through to handle the interaction\n   * whenever the user moves acros screen while active\n   * @param {event} e the event from browser\n   **/\n  function bodyInteract(e) {\n    if (handleActivated) {\n      handleInteract(normalisedClient(e));\n    }\n  }\n\n  /**\n   * if user triggers mouseup on the body while\n   * a handle is active (without moving) then we\n   * trigger an interact event there\n   * @param {event} e the event from browser\n   **/\n  function bodyMouseUp(e) {\n    const el = e.target;\n    // this only works if a handle is active, which can\n    // only happen if there was sliderInteractStart triggered\n    // on the slider, already\n    if (handleActivated) {\n      if (el === slider || slider.contains(el)) {\n        focus = true;\n        if (!targetIsHandle(el)) {\n          handleInteract(normalisedClient(e));\n        }\n      }\n      // fire the stop event for mouse device\n      // when the body is triggered with an active handle\n      eStop();\n    }\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  /**\n   * if user triggers touchend on the body then we\n   * defocus the slider completely\n   * @param {event} e the event from browser\n   **/\n  function bodyTouchEnd(e) {\n    handleActivated = false;\n    handlePressed = false;\n  }\n\n  function bodyKeyDown(e) {\n    if (e.target === slider || slider.contains(e.target)) {\n      keyboardActive = true;\n    }\n  }\n\n  function eStart() {\n    dispatch(\"start\", {\n      activeHandle,\n      value: startValue,\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eStop() {\n    dispatch(\"stop\", {\n      activeHandle,\n      startValue: startValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n\n  function eChange() {\n    dispatch(\"change\", {\n      activeHandle,\n      startValue: startValue,\n      previousValue:\n        typeof previousValue === \"undefined\" ? startValue : previousValue,\n      value: values[activeHandle],\n      values: values.map((v) => alignValueToStep(v)),\n    });\n  }\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --slider: var(--range-slider, #d7dada);\n    --handle-inactive: var(--range-handle-inactive, #99a2a2);\n    --handle: var(--range-handle, #838de7);\n    --handle-focus: var(--range-handle-focus, #4a40d4);\n    --handle-border: var(--range-handle-border, var(--handle));\n    --range-inactive: var(--range-range-inactive, var(--handle-inactive));\n    --range: var(--range-range, var(--handle-focus));\n    --float-inactive: var(--range-float-inactive, var(--handle-inactive));\n    --float: var(--range-float, var(--handle-focus));\n    --float-text: var(--range-float-text, white);\n  }\n  :global(.rangeSlider) {\n    position: relative;\n    border-radius: 100px;\n    height: 0.5em;\n    margin: 1em;\n  }\n  :global(.rangeSlider, .rangeSlider *) {\n    user-select: none;\n  }\n  :global(.rangeSlider.pips) {\n    margin-bottom: 1.8em;\n  }\n  :global(.rangeSlider.pip-labels) {\n    margin-bottom: 2.8em;\n  }\n  :global(.rangeSlider.vertical) {\n    display: inline-block;\n    border-radius: 100px;\n    width: 0.5em;\n    min-height: 200px;\n  }\n  :global(.rangeSlider.vertical.pips) {\n    margin-right: 1.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider.vertical.pip-labels) {\n    margin-right: 2.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider .rangeHandle) {\n    position: absolute;\n    display: block;\n    height: 1.4em;\n    width: 1.4em;\n    top: 0.25em;\n    left: 0.25em;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n  }\n  :global(.rangeSlider .rangeNub),\n  :global(.rangeSlider .rangeHandle:before) {\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n    border-radius: 10em;\n    height: 100%;\n    width: 100%;\n    transition: all 0.2s ease;\n  }\n  :global(.rangeSlider .rangeHandle:before) {\n    content: \"\";\n    left: 1px;\n    top: 1px;\n    bottom: 1px;\n    right: 1px;\n    height: auto;\n    width: auto;\n    box-shadow: 0 0 0 0px var(--handle-border);\n    opacity: 0;\n  }\n  :global(.rangeSlider .rangeHandle.hoverable:hover:before) {\n    box-shadow: 0 0 0 8px var(--handle-border);\n    opacity: 0.2;\n  }\n  :global(.rangeSlider .rangeHandle.hoverable.press:before),\n  :global(.rangeSlider .rangeHandle.hoverable.press:hover:before) {\n    box-shadow: 0 0 0 12px var(--handle-border);\n    opacity: 0.4;\n  }\n  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {\n    border-radius: 10em 10em 10em 1.6em;\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-135deg);\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(135deg);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    display: block;\n    position: absolute;\n    left: 50%;\n    top: -0.5em;\n    transform: translate(-50%, -100%);\n    font-size: 1em;\n    text-align: center;\n    opacity: 0;\n    pointer-events: none;\n    white-space: nowrap;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n    padding: 0.2em 0.4em;\n    border-radius: 0.2em;\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeFloat),\n  :global(.rangeSlider .rangeHandle.hoverable:hover .rangeFloat) {\n    opacity: 1;\n    top: -0.2em;\n    transform: translate(-50%, -100%);\n  }\n  :global(.rangeSlider .rangeBar) {\n    position: absolute;\n    display: block;\n    transition: background 0.2s ease;\n    border-radius: 1em;\n    height: 0.5em;\n    top: 0;\n    user-select: none;\n    z-index: 1;\n  }\n  :global(.rangeSlider.vertical .rangeBar) {\n    width: 0.5em;\n    height: auto;\n  }\n  :global(.rangeSlider) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n  :global(.rangeSlider .rangeBar) {\n    background-color: #99a2a2;\n    background-color: var(--range-inactive);\n  }\n  :global(.rangeSlider.focus .rangeBar) {\n    background-color: #838de7;\n    background-color: var(--range);\n  }\n  :global(.rangeSlider .rangeNub) {\n    background-color: #99a2a2;\n    background-color: var(--handle-inactive);\n  }\n  :global(.rangeSlider.focus .rangeNub) {\n    background-color: #838de7;\n    background-color: var(--handle);\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeNub) {\n    background-color: #4a40d4;\n    background-color: var(--handle-focus);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    color: white;\n    color: var(--float-text);\n    background-color: #99a2a2;\n    background-color: var(--float-inactive);\n  }\n  :global(.rangeSlider.focus .rangeFloat) {\n    background-color: #4a40d4;\n    background-color: var(--float);\n  }\n</style>\n\n<div\n  {id}\n  bind:this={slider}\n  class=\"rangeSlider\"\n  class:range\n  class:vertical\n  class:focus\n  class:min={range === 'min'}\n  class:max={range === 'max'}\n  class:pips\n  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}\n  on:mousedown={sliderInteractStart}\n  on:mouseup={sliderInteractEnd}\n  on:touchstart|preventDefault={sliderInteractStart}\n  on:touchend|preventDefault={sliderInteractEnd}\n>\n  {#each values as value, index}\n    <span\n      role=\"slider\"\n      tabindex=\"0\"\n      class=\"rangeHandle\"\n      class:hoverable={hover}\n      class:active={focus && activeHandle === index}\n      class:press={handlePressed && activeHandle === index}\n      on:blur={sliderBlurHandle}\n      on:focus={sliderFocusHandle}\n      on:keydown={sliderKeydown}\n      style=\"{vertical ? 'top' : 'left'}: {$springPositions[index]}%; z-index: {activeHandle === index ? 3 : 2};\"\n      aria-valuemin={range === true && index === 1 ? values[0] : min}\n      aria-valuemax={range === true && index === 0 ? values[1] : max}\n      aria-valuenow={value}\n      aria-valuetext=\"{prefix}{handleFormatter(value)}{suffix}\"\n      aria-orientation={vertical ? 'vertical' : 'horizontal'}>\n      <span class=\"rangeNub\" />\n      {#if float}\n        <span class=\"rangeFloat\">{prefix}{handleFormatter(value)}{suffix}</span>\n      {/if}\n    </span>\n  {/each}\n  {#if range}\n    <span\n      class=\"rangeBar\"\n      style=\"{vertical ? 'top' : 'left'}: {rangeStart($springPositions)}%; {vertical ? 'bottom' : 'right'}:\n      {rangeEnd($springPositions)}%;\" />\n  {/if}\n  {#if pips}\n    <RangePips\n      {values}\n      {min}\n      {max}\n      {step}\n      {range}\n      {vertical}\n      {all}\n      {first}\n      {last}\n      {rest}\n      {pipstep}\n      {prefix}\n      {suffix}\n      {formatter}\n      {focus}\n      {percentOf} />\n  {/if}\n</div>\n\n<svelte:window\n  on:mousedown={bodyInteractStart}\n  on:touchstart={bodyInteractStart}\n  on:mousemove={bodyInteract}\n  on:touchmove={bodyInteract}\n  on:mouseup={bodyMouseUp}\n  on:touchend={bodyTouchEnd}\n  on:keydown={bodyKeyDown} />\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature, point, lineString, isObject } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature$$1.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature$$1.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature$$1,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature$$1.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature$$1.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","<script>\n\timport { onMount } from 'svelte'\n\timport RangeSlider from 'svelte-range-slider-pips'\n\timport booleanIntersects from '@turf/boolean-intersects'\n\n\texport let maps\n\texport let geoMasks\n\texport let yearsPadding\n\texport let yearsRange\n\texport let mapIndex = 0\n\n\tlet sliderStep = 10\n\n\tlet map\n\tlet mapYearsRange\n\n\t$: map = maps[mapIndex]\n\t$: mapYearsRange = [\n\t\tMath.min(...map.years) - yearsPadding,\n\t\tMath.max(...map.years) + yearsPadding\n\t]\n\t$: updateMap(map)\n\n\tlet leafletMap\n\n\tlet locations\n\tlet locationsLayer\n\tlet tileLayer\n\n\tconst emptyGeoJSON = {\n\t\ttype: 'FeatureCollection',\n\t\tfeatures: []\n\t}\n\n\tfunction handleKeydown (event) {\n\t\tif (event.key === '[') {\n\t\t\tpreviousMap()\n\t\t} else if (event.key === ']') {\n\t\t\tnextMap()\n\t\t} else if (event.code === 'Space') {\n\t\t\tif (tileLayer) {\n\t\t\t\ttileLayer.setOpacity(0)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleKeyup (event) {\n \t\tif (event.code === 'Space') {\n\t\t\tif (tileLayer) {\n\t\t\t\ttileLayer.setOpacity(1)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleResize () {\n\t\tif (window.innerWidth < 600) {\n\t\t\tsliderStep = 50\n\t\t} else if (window.innerWidth < 1000) {\n\t\t\tsliderStep = 20\n\t\t} else {\n\t\t\tsliderStep = 10\n\t\t}\n\t}\n\n\tfunction yearsOverlap (yearsRange1, yearsRange2) {\n\t\treturn yearsRange1[0] <= yearsRange2[1] && yearsRange2[0] <= yearsRange1[1]\n\t}\n\n\tfunction sliderChange (event) {\n\t\tconst yearsRange = event.detail.values\n\t\tupdateLocations(yearsRange, false)\n\t}\n\n\tfunction updateLocations (yearsRange, fitBounds = true) {\n\t\tif (locationsLayer && locations) {\n\n\t\t\tconst filteredGeoMasks = geoMasks.features\n\t\t\t\t.filter((feature) => {\n\t\t\t\t\tconst imageId = feature.properties.imageService['@id']\n\t\t\t\t\treturn imageId.endsWith(map.id)\n\t\t\t\t})\n\n\t\t\tlet geoMask\n\t\t\tif (filteredGeoMasks && filteredGeoMasks.length === 1) {\n\t\t\t\tgeoMask = filteredGeoMasks[0]\n\t\t\t}\n\n\t\t\tconst locationsFilteredByYear = {\n\t\t\t\ttype: 'FeatureCollection',\n\t\t\t\tfeatures: locations.features\n\t\t\t\t\t.filter((feature) => {\n\t\t\t\t\t\tconst featureYears = [\n\t\t\t\t\t\t\tparseInt(feature.properties.startyear) || -Infinity,\n\t\t\t\t\t\t\tparseInt(feature.properties.endyear) || Infinity\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\treturn yearsOverlap(yearsRange, featureYears) // && booleanIntersects(geoMask, feature)\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst locationsFilteredByYearAndGeometry = {\n\t\t\t\ttype: 'FeatureCollection',\n\t\t\t\tfeatures: locations.features\n\t\t\t\t\t.filter((feature) => {\n\t\t\t\t\t\tconst featureYears = [\n\t\t\t\t\t\t\tparseInt(feature.properties.startyear) || -Infinity,\n\t\t\t\t\t\t\tparseInt(feature.properties.endyear) || Infinity\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\treturn yearsOverlap(yearsRange, featureYears) && booleanIntersects(geoMask, feature)\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\tlocationsLayer.clearLayers()\n\t\t\tlocationsLayer.addData(locationsFilteredByYear)\n\t\t\tif (fitBounds) {\n\t\t\t\tleafletMap.fitBounds(L.geoJson(locationsFilteredByYearAndGeometry).getBounds(), {\n\t\t\t\t\tpadding: [5, 5]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction previousMap () {\n\t\tmapIndex = (mapIndex - 1 + maps.length) % maps.length\n\t}\n\n\tfunction nextMap () {\n\t\tmapIndex = (mapIndex + 1) % maps.length\n\t}\n\n\tfunction updateMap (map) {\n\t\tif (!locations) {\n\t\t\treturn\n\t\t}\n\n\t\tconst mapYearsRange = [\n\t\t\tMath.min(...map.years) - yearsPadding,\n\t\t\tMath.max(...map.years) + yearsPadding\n\t\t]\n\n\t\tupdateLocations(mapYearsRange)\n\n\t\tif (tileLayer) {\n\t\t\ttileLayer.addTo(leafletMap)\n\t\t\ttileLayer.setUrl(map.tiles)\n\t\t}\n\t}\n\n\tfunction createPopup (feature) {\n\t\tconst properties = feature.properties\n\t\tconst width = 250\n\n\t\tlet html = [\n\t\t\t`<h3>${properties.label}</h3>`\n\t\t]\n\n\t\tif (properties.startyear || properties.endyear) {\n\t\t\tconst startYear = properties.startyear || ''\n\t\t\tconst endYear = properties.endyear || ''\n\n\t\t\thtml.push(`<span class=\"years\">${startYear} – ${endYear}</span>⁠`)\n\t\t}\n\n\t\tif (properties.image) {\n\t\t\thtml.push(`<a href=\"https://rotterdamspubliek.nl/plekken/plek.php?qid=${properties.wdid}\"><img style=\"width: ${width}px;\" src=\"${properties.image}?width=${width}px\" /></a>`)\n\t\t}\n\n\t\thtml.push(`<p><a href=\"https://rotterdamspubliek.nl/plekken/plek.php?qid=${properties.wdid}\">Bekijk op Rotterdams Publiek</a></p>`)\n\n\t\treturn html.join('\\n')\n\t}\n\n\tonMount(async () => {\n\t \tleafletMap = L.map('map', {\n\t\t\t minZoom: 13,\n\t\t\t maxZoom: 18,\n\t\t\t attributionControl: false\n\t\t }).setView([51.9200, 4.4895], 13)\n\n\t\t// const tileUrl = 'https://stamen-tiles.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png'\n\t\tconst tileUrl = 'https://a.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png'\n\n\t\tconst baseLayer = L.tileLayer(tileUrl, {\n\t\t\tmaxZoom: 18\n\t\t}).addTo(leafletMap)\n\n\t\ttileLayer = L.tileLayer('', {\n\t\t\tmaxZoom: 18\n\t\t})\n\n\t\tconst style = {\n\t\t\tcolor: '#950305',\n\t\t\tweight: 3,\n\t\t\topacity: 0.8,\n\t\t\tfillOpacity: 0.3\n\t\t}\n\n\t\tlocationsLayer = L.geoJSON(emptyGeoJSON, {\n\t\t\tonEachFeature: (feature, layer) => {\n        layer.bindPopup(createPopup(feature))\n    \t},\n\t\t\tpointToLayer: (feature, latlng) => {\n\t\t\t\treturn new L.CircleMarker(latlng, {\n\t\t\t\t\t...style,\n\t\t\t\t\tradius: 5,\n\t\t\t\t\tweight: 2,\n\t\t\t\t})\n\t\t\t},\n\t\t\tstyle\n\t\t}).addTo(leafletMap)\n\t})\n\n\tasync function fetchLocations (url) {\n\t\tconst response = await fetch(url)\n\t\tlocations = await response.json()\n\n\t\tupdateMap(map)\n\t}\n\n\tfetchLocations('https://raw.githubusercontent.com/mmmenno/rotterdams-publiek/master/plekken/kaart/locaties.geojson')\n\thandleResize()\n</script>\n\n<main>\n\t<div id=\"map\"></div>\n\t<footer>\n\t\t<div class=\"maps\">\n\t\t\t<div class=\"previous\">\n\t\t\t\t<button on:click={previousMap}>←&nbsp;<span title=\"Volgende kaart - of gebruik de [-toets\">Vorige</span></button>\n\t\t\t</div>\n\t\t\t<div class=\"metadata\">\n\t\t\t\t<a class=\"title\" title={map.displayTitle} href={map.handle}>{map.displayTitle}</a>\n\t\t\t\t<span class=\"years\">{map.years.join(' – ')}</span>\n\t\t\t</div>\n\t\t\t<div class=\"next\">\n\t\t\t\t<button on:click={nextMap}><span title=\"Volgende kaart - of gebruik de ]-toets\">Volgende</span>&nbsp;→</button>\n\t\t\t</div>\n\t\t</div>\n  \t<div class=\"controls\">\n\t\t\t<RangeSlider range\n\t\t\t\ton:change={sliderChange}\n\t\t\t\tspringValues={{ stiffness: 1, damping: 1 }}\n\t\t\t\tpips={true} pipstep={sliderStep}\n\t\t\t\tfloat={true} hover={true}\n\t\t\t\tfirst='label' last='label' rest='label'\n\t\t\t\tmin={Math.floor(yearsRange[0] / 10) * 10} max={2020}\n\t\t\t\tvalues={mapYearsRange} />\n\t\t</div>\n\t</footer>\n</main>\n<svelte:window\n\ton:keyup={handleKeyup}\n\ton:keydown={handleKeydown}\n\ton:resize={handleResize} />\n<style>\n:root {\n\t--red: #c2675d;\n\t--range-range: var(--red);\n\t--range-float: var(--red);\n\t--range-handle: var(--red);\n\t--range-handle-focus: var(--red);\n}\n\nmain {\n\twidth: 100%;\n\theight: 100%;\n\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n#map {\n\tflex-grow: 1;\n}\n\nfooter {\n\tdisplay: flex;\n\tflex-direction: column;\n\tjustify-content: space-between;\n\tpadding: 0.5em;\n}\n\n.maps {\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: space-between;\n\tpadding-bottom: 0.5em;\n}\n\n@media only screen and (max-width: 600px) {\n\t.maps button span {\n\t\tdisplay: none;\n\t}\n}\n\n.previous {\n\tpadding-right: 0.5em;\n}\n\n.next {\n\tpadding-left: 0.5em;\n}\n\n.previous, .next {\n\tflex-shrink: 0;\n}\n\n.metadata {\n\tdisplay: inline-block;\n\toverflow: hidden;\n\twhite-space: nowrap;\n\ttext-overflow: ellipsis;\n}\n\n.title, .title:visited {\n\tcolor: black;\n}\n\nfooter button {\n\tmargin: 0;\n  padding: 0;\n\tcolor: var(--red);\n\tbackground: none;\n\tborder: none;\n\tfont-weight: bold;\n\tcursor: pointer;\n}\n\nfooter button:hover span {\n\ttext-decoration: underline;\n}\n</style>\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","/* global URLSearchParams */\n\nimport App from './App.svelte'\n\nimport maps from '../maps.yaml'\nimport geoMasks from '../geo-masks/all-geo-masks.geojson'\n\nconst yearsPadding = 10\n\nconst path = window.location.hash.slice(1)\nconst urlParams = new URLSearchParams(path)\nconst hashYear = parseInt(urlParams.get('year'))\n\nlet mapIndex\nlet minYearDiff = Infinity\n\nconst yearsRange = maps.reduce((yearsRange, map, index) => {\n  const minYear = Math.min(...map.years)\n  const maxYear = Math.max(...map.years)\n\n  if (hashYear) {\n    let yearDiff = 0\n    if (hashYear < minYear) {\n      yearDiff = minYear - hashYear\n    } else if (hashYear > maxYear) {\n      yearDiff = hashYear - maxYear\n    }\n\n    if (yearDiff < minYearDiff) {\n      minYearDiff = yearDiff\n      mapIndex = index\n    }\n  }\n\n  return [\n    Math.min(yearsRange[0], minYear - yearsPadding),\n    Math.max(yearsRange[1], maxYear + yearsPadding)\n  ]\n}, [Infinity, -Infinity])\n\nconst app = new App({\n  target: document.body,\n  props: {\n    geoMasks,\n    mapIndex,\n    maps: maps\n      .filter((map) => map.tiles),\n    yearsPadding,\n    yearsRange\n  }\n})\n\nexport default app\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","callbacks","unsub","subscribe","unsubscribe","is_client","window","now","performance","Date","raf","cb","requestAnimationFrame","tasks","Set","run_tasks","task","c","delete","f","size","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","prevent_default","preventDefault","call","this","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","wholeText","toggle_class","toggle","classList","current_component","set_current_component","get_current_component","Error","createEventDispatcher","type","detail","e","createEvent","initCustomEvent","custom_event","slice","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","flush","update","pop","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","transition_in","block","local","transition_out","o","globals","globalThis","global","create_component","mount_component","on_mount","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","context","Map","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","$destroy","index","indexOf","splice","$$props","obj","$$set","keys","subscriber_queue","is_date","prototype","toString","tick_spring","last_value","current_value","target_value","delta","velocity","dt","opts","stiffness","damping","inv_mass","Math","abs","precision","settled","getTime","isArray","_","next_value","k","spring","start","stop","subscribers","set","new_value","run_queue","s","invalidate","subscriber","writable","last_time","current_token","inv_mass_recovery_rate","cancel_task","token","hard","soft","rate","promise","fulfill","loop","min","fulfil","range","max","step","values","vertical","pipstep","all","first","last","prefix","suffix","formatter","v","focus","percentOf","pipStep","pipCount","parseInt","pipVal","val","isSelected","some","inRange","r","el","previousElementSibling","normalisedClient","includes","touches","pushy","float","hover","pips","id","handleFormatter","springValues","dispatch","slider","startValue","previousValue","handleActivated","handlePressed","keyboardActive","activeHandle","springPositions","parseFloat","toFixed","getSliderDimensions","getBoundingClientRect","handleInteract","clientPos","dims","hPos","hPercent","hVal","clientY","top","height","clientX","left","width","moveHandle","alignValueToStep","eStop","clampValue","remainder","aligned","trimRange","perc","isNaN","handle","jump","ctrlKey","metaKey","shiftKey","prevent","key","stopPropagation","closest","sort","getClosestHandle","contains","handles","querySelectorAll","isHandle","isChild","targetIsHandle","feature","geom","properties","feat","bbox","geometry","lineString","coordinates","featureCollection","features","fc","isNumber","num","getCoords","coords","getGeom","geojson","booleanPointInPolygon","point","polygon","pt","coord","getCoord","polys","inBBox","insidePoly","inRing","ignoreBoundary","inHole","ring","isInside","j","xi","yi","xj","yj","featureEach","flattenEach","g","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","undefined","geometries","geomEach","geomType","multiFeatureIndex","coordinate","lineSegment","results","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","module","quickselect","arr","right","compare","quickselectStep","defaultCompare","n","z","log","exp","sd","sqrt","floor","t","swap","tmp","factory","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","toBBox","distBBox","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","multiSelect","mid","stack","_all","search","result","len","childBBox","nodesToSearch","collides","load","_build","_splitRoot","tmpNode","_insert","remove","parent","goingUp","path","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","_i","coordinates_1","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","exports","factors","lengthToRadians","distance","radiansToDegrees","PI","defineProperty","centimeters","earthRadius","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","acres","hectares","_options","multiplier","round","bearing","angle","originalUnit","finalUnit","startFactor","areaFactors","finalFactor","input","constructor","coordEach","excludeWrapCoord","wrapShrink","coordIndex","geomIndex","geometryIndex","propEach","helpers","segmentEach","segmentIndex","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","initialValue","currentProperties","currentFeature","currentGeometry","started","currentLine","isObject","meta_1","turfBBox","default","meta","geojsonRbush","tree","equals","json","lineIntersect","line1","line2","unique","intersect","match","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","poly","coordsToLine","polygonToLine","multiPoly","lines","multiPolygonToLine","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","isPointOnLine","lineString1","lineString2","isLineOnLine","isLineInPoly","_a","_b","_c","isPolyInPoly","disjoint","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","displayTitle","years","yearsOverlap","yearsRange1","yearsRange2","mapYearsRange","leafletMap","locations","locationsLayer","tileLayer","maps","geoMasks","yearsPadding","yearsRange","mapIndex","sliderStep","emptyGeoJSON","handleResize","innerWidth","updateLocations","fitBounds","filteredGeoMasks","imageService","endsWith","geoMask","locationsFilteredByYear","featureYears","startyear","endyear","locationsFilteredByYearAndGeometry","clearLayers","addData","L","geoJson","getBounds","padding","previousMap","nextMap","updateMap","addTo","setUrl","tiles","minZoom","maxZoom","attributionControl","setView","style","color","weight","opacity","fillOpacity","geoJSON","onEachFeature","layer","bindPopup","html","label","startYear","endYear","image","wdid","createPopup","pointToLayer","latlng","CircleMarker","radius","url","response","fetch","fetchLocations","code","setOpacity","location","hash","urlParams","URLSearchParams","hashYear","get","minYearDiff","minYear","maxYear","yearDiff","body"],"mappings":"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"}